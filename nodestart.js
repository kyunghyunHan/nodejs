/**node js statrt
 * 
 * 노드는 자바스크랍트 런타임 
 * 런타임은 특정언어로 만든 프로그램들을 실행할수 있는 환경을 뜻함(자바스크립트 실행기)
 * 
 * 이벤트 기반이란 이벤트가 발생할 떄 미리 저장해둔 작업을 수행하는 방식
 * 
 * 이벤트리스너에 콜백함수를 등록후 호출가능
 * 
 * 노드는 자바스크립트 코드의 맨위부터 한줄씩 실행 함수 호출부분을 발견하였다면 호출한 함수를 호출스택에 넣는다
 */

function first(){
    second();
    console.log('첫번쨰');
}

function second(){
    third();
    console.log('두번쨰');

}
function third(){
    console.log('세번쨰');
}
first();

//세번쨰 두번쨰 첫번쨰

function run(){
    console.log('3초후 실행');
}
console.log('시작');
setTimeout(run,3000);
console.log('끝');

//시작 끝 3초후 실행


/**이벤트루프- 이벤트 발생시 호출할 콜백함수들을 관리하고,호출된 콜백함수의 실행순서를 결정하는 역활을 담당 ,노드가 종료될떄까지 이벤트 처리를 위한 작업을 반복하므로 루프라부름
 * 
 * 백그라운드 - settimeout 같은 타이머나 이밴트 리스너들이 대기하는 곳 . 자바스크립트가 아닌 다른 언어로 작성된 프로그럄이라 봐도 무방,여러 작업이 동시에 실핼될수 있음
 * 
 * 태스크 큐 - 이벤트 발생후 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백함수를 보냄, 정해진 순서대로 콜백들이 줄을 서있으므로 콜백큐라 부름
 * 콜백들은 보통 완료된 순서대로 줄을 서있지만 특정한 경우에는 순서가 바뀌기도 함
 * 
 * 
 * 순서 호출스택 - 백그라운드 -    태스트쿠
 * 
 * 먼저 전역컨텍스트인 anoonymous가 호출스택에 들어감 그뒤 settimeout이 호춯스택에 들어감 호출스택에 들어간 순서와 반대로 실행되므로 settimeout이 먼저실행되며,
 * settimeout이 실행되면 타이머와 함꼐 run콜백을 백그라운드로 보내고 settimeout은 호출스택에서 빠지고 그다음 annoymous기 호출스택에서 빠짐 , 백그라운드에서는
 * 3초를 센후 run함수를 태스크 큐로 보내고 3초를 세었다는 것은 백그라운드에 맞겨진 작업이 완료된 것으로 이해
 * annoymous까지 실행이 완료되어 호출스택이 비어짐 호출스택이 비어있으면 태스크큐애서 함수를 하나씪 가져와 호출스택에 넣고 실행
 * 이벤트 루프가 run콜백을 테스크쿠에서 꺼네 호출스택으로 올림 호출뒤 실행
 * 
 * 
 * 자바스크립트 코드는 동시에 실행될수 없음  I/O작업은 동시에 처리될수 있음
 * 
 * I/O는 입력 출력을 의미 파일읽기,쓰기,폴더 만들기 등이나 네트워크를 통한 요청이나 작업이 I/O의 일종
 * 이러한 작업을 할때 노드는 노블로킹 작업방식으로 처리 논블로킹이란 이전작업이 완료될떄 까지 대기하지 않고 다음 작업을 수행 블로킹은 이전작업이 끝나야지만 다음 작업을 수행
 * 
 * 노드는 I/O작업을 백그라운드로 넘겨 동시에 처리 따라서 동시에 처리될 수 있는 작업들은 최대한 묶어서 백그라운드로 넘겨야 실행이 절약
 */

function longRunningTask(){
    //오래걸리는 작업
    console.log('작업 끝');
}

console.log('시작');
longRunningTask();
console.log('다음작업');

//시작 작업끝 다음작업


//settimeout을 이용하여 코드변경

function longRunningTask(){
    //오래걸리는 작업
    console.log('작업끝');
}
console.log('시작');
setTimeout(longRunningTask,0);
console.log('다음작업');

// 시작 다음작업 작업끝

/**settimeout은 코드를 논 블로킹으로 만들기 위해 사용하는 기법중 하나이다 다른 방식으로 주로 사용하지만
 * 
 * 논블로킹을 통해 실행순서를 바꿔줌으로써 그작업떄문에 간단한 작업들이 대기하는 상황을 막을 수 있음 논블로킹과 동시가 같은 의미가아님 !!

settimeout을 0으로 설정햇으므로 바로 실행될것 같지만 노드에서는 1ms 의 지연시간 , 브라우저에서는 4ms의 지연시간이 있음

*/

/**싱글 스레드
 * 
 * 스레드가 하나뿐인 것을 의미
 * 
 * 프로세스와 스레드의 차이
 * 
 * 프로세스는 운영체제에서 할당하는 작업의 단위 노드나 웹브라우저같은 프로그램은 개별적인 프로세스이다.프로세스 간에는 메모리등의 자원을공유하지 안음\
 * 스래드는 프로세스 내에서 실행되는 흐름의 단위 프로세스는 스래드를 여러개 생성하여 작업을 동시에 처리할숭 있음 스레드들은 부모 프로세스의 자원을 공유 같은 주소의메모리에 접근이가능하므로 데이터를 공유
 * 
 * 
 * 노드를 생성하면 프로새스 하나가 생성 이떄 내부적으로 스레드를 여러개 생성,그중 제어할수 있는 스레드는 하나
 * 
 * 언틋보면 여러개의 일을 동시에 처리할수 있는 멀티스레드가 싱글스레드 보다 좋아보일수 있음
 * 
 * 싱글스레드
 * 
 * -스레드 하나가 일을처리
 * 
 * 싱글 스레드 논블로킹 모델  
 * 
 * -노드가 처리하고 있는 방식 ,스레드 하나가 혼자서 여러가지 일을처리 일이 많은경우 버거울수 있음
 * 
 * 멀티 스레드
 * 
 * 여러개의 스레드가 각자의 일을 처리 빈 스레드가 발생할수 있음 스레드 처리에도 비용발생
 * 
 * 
 * 
 * 멀티 프로세싱
 * 
 * 멀티 스레드가 모두 논 블로킹 방식으로 알을 처리
 *  */


/**프로세스 
 * 
 * 운영체제로부터 자원을 할당받는 작업의 단위
디스크로부터 메모리에 적재되어 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 함
함수의 매개변수, 복귀 주소, 로컬 변수와 같은 임시 자료를 저장하는 프로세스 "스택"과 전역 변수들을 저장하는 데이터 섹션, 프로세스 실행 중에 동적으로 할당되는 메모리인 "힙"을 포함
 * 
 */

/**스레드
 * 
 * 프로세스가 할당받은 자원을 이용하는 실행의 단위
한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 Heap, Data, Code 영역을 공유
하나의 프로세스를 다수의 실행 단위인 스레드로 구분하여, 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라고 함.
이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 가지고 있음
 */


/**싱글스레드
 * 하나의 프로세스에서 하나의 스레드 실행
하나의 레지스터와 스택으로 표현.

 * 장점

자원 접근데 대한 동기화를 신경쓰지 않아도 된다.
여러개의 스레드가 공유된 자원을 사용할 경우, 각 스레드가 원하는 결과를 얻게 하려면 공용 자원에 대한 접근이 통제되어야 하며, 이 작업은 프로그래머에게 많은 노력을 요구하고 많은 비용을 발생시킨다. 단일 스레드 모델에서는 이러한 작업이 필요하지 않다.

작업전환 작업을 요구하지 않는다.
작업전환은 여러 개의 프로세스가 하나의 프로세서를 공유할 때 발생하는 작업으로 많은 비용을 필요로 한다.


 * 단점
여러 개의 CPU를 활용하지 못한다.
프로세서를 최대한 활용하게 하려면 cluster 모듈을 사용하거나, 외부에서 여러 개의 프로그램 인스턴스를 실행시키는 방법을 사용해야 한다.

두 개의 작업을 하나의 스레드로 처리하는 경우와, 두 개의 스레드로 처리하는 경우를 가정했을 때, 후자의 경우는 짧은 시간 동안 2개의 스레드가 번갈아가면서 작업을 수행한다. 그래서 동시에 두 작업이 처리되는 것과 같이 느끼게 된다.

하지만 오히여 두 개의 스레드로 작업한 시간이 싱글스레드로 작업한 시간보다 더 걸릴 수도 있는데, 그 이유는 스레드 간의 작업전환(context switching)에 시간이 걸리기 때문이다.

따라서 단순히 CPU만을 사용하는 계산작업이라면, 오히려 멀티스레드보다 싱글스레드로 프로그래밍하는 것이 더 효율적이다.


 */

/**멀티스레드
 * 프로그램을 다수의 실행 단위로 나누어 실행.
프로세스 내에서 자원을 공유하여 자원 생성과 관리의 중복을 최소화
서버가 많은 요청을 효율적으로 수행할 수 있는 환경을 제공
각각의 스레드가 고유의 레지스터와 스택으로 표현됨.
 * 장점
새로운 프로세스를 생성하는 것보다 기존 프로세스에서 스레드를 생성하는 것이 빠르다.
프로세스의 자원과 상태를 공유하여 효율적으로 운영이 가능하다.
프로세스의 작업전환보다 스레드의 작업전환이 더 빠르다.
 * 단점
하나의 스레드만 실행중일 때는 실행시간이 오히려 지연될 수 있다.
멀티 스레딩을 위해 운영체제의 지원이 필요하다.
스레드 스케쥴링을 신경써야 한다.

 * 
 */

/**멀티프로세스
 * 
 * 부모-자식 관계라고 해도 자신만의 메모리 영역을 가지게 된다.
환경변수와 프로세스 핸들 테이블이 상속 가능할 뿐 결국 독립적인 관계이다.
fork를 통해 프로세스를 복사한다.
유닉스 계열에서 ps 명령어로 현재 수행되고 있는 프로세스를 확인할 수 있다.
프로세스 간의 통신을 하려면 IPC(Inter Process Communication; 세마포어, 큐, 공유메모리)를 통해야 한다


장점

여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽고 다른 프로세스에는 영향이 확산되지 않는다.


단점
context switching에서의 오버헤드
context switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 된다.
프로세스는 각각의 독룁된 메모리 영역을 할당 받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, context switching이 발생하면 캐슁에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다.
프로세스 사이의 어렵고 복잡한 통신 기법 (IPC)
프로세스는 각각의 독립된 메모리 영역을 할당 받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다


CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는데 이 과정을 context switching이라 한다.
구체적으로, 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.
 */